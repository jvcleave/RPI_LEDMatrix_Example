#pragma once
#include "wiringPi.h"


#define HT1632_READ  0x6
#define HT1632_WRITE 0x5
#define HT1632_COMMAND 0x4

#define HT1632_SYS_DIS 0x00
#define HT1632_SYS_EN 0x01
#define HT1632_LED_OFF 0x02
#define HT1632_LED_ON 0x03
#define HT1632_BLINK_OFF 0x08
#define HT1632_BLINK_ON 0x09
#define HT1632_SLAVE_MODE 0x10
#define HT1632_MASTER_MODE 0x14
#define HT1632_INT_RC 0x18
#define HT1632_EXT_CLK 0x1C
#define HT1632_PWM_CONTROL 0xA0

#define HT1632_COMMON_8NMOS  0x20
#define HT1632_COMMON_16NMOS  0x24
#define HT1632_COMMON_8PMOS  0x28
#define HT1632_COMMON_16PMOS  0x2C


#define _BV(bit) (1 << (bit))

static unsigned char  font[] = {
    0x00, 0x00, 0x00, 0x00, 0x00,   
    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,   
    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,   
    0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 
    0x18, 0x3C, 0x7E, 0x3C, 0x18, 
    0x1C, 0x57, 0x7D, 0x57, 0x1C, 
    0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 
    0x00, 0x18, 0x3C, 0x18, 0x00, 
    0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 
    0x00, 0x18, 0x24, 0x18, 0x00, 
    0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 
    0x30, 0x48, 0x3A, 0x06, 0x0E, 
    0x26, 0x29, 0x79, 0x29, 0x26, 
    0x40, 0x7F, 0x05, 0x05, 0x07, 
    0x40, 0x7F, 0x05, 0x25, 0x3F, 
    0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 
    0x7F, 0x3E, 0x1C, 0x1C, 0x08, 
    0x08, 0x1C, 0x1C, 0x3E, 0x7F, 
    0x14, 0x22, 0x7F, 0x22, 0x14, 
    0x5F, 0x5F, 0x00, 0x5F, 0x5F, 
    0x06, 0x09, 0x7F, 0x01, 0x7F, 
    0x00, 0x66, 0x89, 0x95, 0x6A, 
    0x60, 0x60, 0x60, 0x60, 0x60, 
    0x94, 0xA2, 0xFF, 0xA2, 0x94, 
    0x08, 0x04, 0x7E, 0x04, 0x08, 
    0x10, 0x20, 0x7E, 0x20, 0x10, 
    0x08, 0x08, 0x2A, 0x1C, 0x08, 
    0x08, 0x1C, 0x2A, 0x08, 0x08, 
    0x1E, 0x10, 0x10, 0x10, 0x10, 
    0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 
    0x30, 0x38, 0x3E, 0x38, 0x30, 
    0x06, 0x0E, 0x3E, 0x0E, 0x06, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x5F, 0x00, 0x00, 
    0x00, 0x07, 0x00, 0x07, 0x00, 
    0x14, 0x7F, 0x14, 0x7F, 0x14, 
    0x24, 0x2A, 0x7F, 0x2A, 0x12, 
    0x23, 0x13, 0x08, 0x64, 0x62, 
    0x36, 0x49, 0x56, 0x20, 0x50, 
    0x00, 0x08, 0x07, 0x03, 0x00, 
    0x00, 0x1C, 0x22, 0x41, 0x00, 
    0x00, 0x41, 0x22, 0x1C, 0x00, 
    0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 
    0x08, 0x08, 0x3E, 0x08, 0x08, 
    0x00, 0x80, 0x70, 0x30, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x60, 0x60, 0x00, 
    0x20, 0x10, 0x08, 0x04, 0x02, 
    0x3E, 0x51, 0x49, 0x45, 0x3E, 
    0x00, 0x42, 0x7F, 0x40, 0x00, 
    0x72, 0x49, 0x49, 0x49, 0x46, 
    0x21, 0x41, 0x49, 0x4D, 0x33, 
    0x18, 0x14, 0x12, 0x7F, 0x10, 
    0x27, 0x45, 0x45, 0x45, 0x39, 
    0x3C, 0x4A, 0x49, 0x49, 0x31, 
    0x41, 0x21, 0x11, 0x09, 0x07, 
    0x36, 0x49, 0x49, 0x49, 0x36, 
    0x46, 0x49, 0x49, 0x29, 0x1E, 
    0x00, 0x00, 0x14, 0x00, 0x00, 
    0x00, 0x40, 0x34, 0x00, 0x00, 
    0x00, 0x08, 0x14, 0x22, 0x41, 
    0x14, 0x14, 0x14, 0x14, 0x14, 
    0x00, 0x41, 0x22, 0x14, 0x08, 
    0x02, 0x01, 0x59, 0x09, 0x06, 
    0x3E, 0x41, 0x5D, 0x59, 0x4E, 
    0x7C, 0x12, 0x11, 0x12, 0x7C, 
    0x7F, 0x49, 0x49, 0x49, 0x36, 
    0x3E, 0x41, 0x41, 0x41, 0x22, 
    0x7F, 0x41, 0x41, 0x41, 0x3E, 
    0x7F, 0x49, 0x49, 0x49, 0x41, 
    0x7F, 0x09, 0x09, 0x09, 0x01, 
    0x3E, 0x41, 0x41, 0x51, 0x73, 
    0x7F, 0x08, 0x08, 0x08, 0x7F, 
    0x00, 0x41, 0x7F, 0x41, 0x00, 
    0x20, 0x40, 0x41, 0x3F, 0x01, 
    0x7F, 0x08, 0x14, 0x22, 0x41, 
    0x7F, 0x40, 0x40, 0x40, 0x40, 
    0x7F, 0x02, 0x1C, 0x02, 0x7F, 
    0x7F, 0x04, 0x08, 0x10, 0x7F, 
    0x3E, 0x41, 0x41, 0x41, 0x3E, 
    0x7F, 0x09, 0x09, 0x09, 0x06, 
    0x3E, 0x41, 0x51, 0x21, 0x5E, 
    0x7F, 0x09, 0x19, 0x29, 0x46, 
    0x26, 0x49, 0x49, 0x49, 0x32, 
    0x03, 0x01, 0x7F, 0x01, 0x03, 
    0x3F, 0x40, 0x40, 0x40, 0x3F, 
    0x1F, 0x20, 0x40, 0x20, 0x1F, 
    0x3F, 0x40, 0x38, 0x40, 0x3F, 
    0x63, 0x14, 0x08, 0x14, 0x63, 
    0x03, 0x04, 0x78, 0x04, 0x03, 
    0x61, 0x59, 0x49, 0x4D, 0x43, 
    0x00, 0x7F, 0x41, 0x41, 0x41, 
    0x02, 0x04, 0x08, 0x10, 0x20, 
    0x00, 0x41, 0x41, 0x41, 0x7F, 
    0x04, 0x02, 0x01, 0x02, 0x04, 
    0x40, 0x40, 0x40, 0x40, 0x40, 
    0x00, 0x03, 0x07, 0x08, 0x00, 
    0x20, 0x54, 0x54, 0x78, 0x40, 
    0x7F, 0x28, 0x44, 0x44, 0x38, 
    0x38, 0x44, 0x44, 0x44, 0x28, 
    0x38, 0x44, 0x44, 0x28, 0x7F, 
    0x38, 0x54, 0x54, 0x54, 0x18, 
    0x00, 0x08, 0x7E, 0x09, 0x02, 
    0x18, 0xA4, 0xA4, 0x9C, 0x78, 
    0x7F, 0x08, 0x04, 0x04, 0x78, 
    0x00, 0x44, 0x7D, 0x40, 0x00, 
    0x20, 0x40, 0x40, 0x3D, 0x00, 
    0x7F, 0x10, 0x28, 0x44, 0x00, 
    0x00, 0x41, 0x7F, 0x40, 0x00, 
    0x7C, 0x04, 0x78, 0x04, 0x78, 
    0x7C, 0x08, 0x04, 0x04, 0x78, 
    0x38, 0x44, 0x44, 0x44, 0x38, 
    0xFC, 0x18, 0x24, 0x24, 0x18, 
    0x18, 0x24, 0x24, 0x18, 0xFC, 
    0x7C, 0x08, 0x04, 0x04, 0x08, 
    0x48, 0x54, 0x54, 0x54, 0x24, 
    0x04, 0x04, 0x3F, 0x44, 0x24, 
    0x3C, 0x40, 0x40, 0x20, 0x7C, 
    0x1C, 0x20, 0x40, 0x20, 0x1C, 
    0x3C, 0x40, 0x30, 0x40, 0x3C, 
    0x44, 0x28, 0x10, 0x28, 0x44, 
    0x4C, 0x90, 0x90, 0x90, 0x7C, 
    0x44, 0x64, 0x54, 0x4C, 0x44, 
    0x00, 0x08, 0x36, 0x41, 0x00, 
    0x00, 0x00, 0x77, 0x00, 0x00, 
    0x00, 0x41, 0x36, 0x08, 0x00, 
    0x02, 0x01, 0x02, 0x04, 0x02, 
    0x3C, 0x26, 0x23, 0x26, 0x3C, 
    0x1E, 0xA1, 0xA1, 0x61, 0x12, 
    0x3A, 0x40, 0x40, 0x20, 0x7A, 
    0x38, 0x54, 0x54, 0x55, 0x59, 
    0x21, 0x55, 0x55, 0x79, 0x41, 
    0x21, 0x54, 0x54, 0x78, 0x41, 
    0x21, 0x55, 0x54, 0x78, 0x40, 
    0x20, 0x54, 0x55, 0x79, 0x40, 
    0x0C, 0x1E, 0x52, 0x72, 0x12, 
    0x39, 0x55, 0x55, 0x55, 0x59, 
    0x39, 0x54, 0x54, 0x54, 0x59, 
    0x39, 0x55, 0x54, 0x54, 0x58, 
    0x00, 0x00, 0x45, 0x7C, 0x41, 
    0x00, 0x02, 0x45, 0x7D, 0x42, 
    0x00, 0x01, 0x45, 0x7C, 0x40, 
    0xF0, 0x29, 0x24, 0x29, 0xF0, 
    0xF0, 0x28, 0x25, 0x28, 0xF0, 
    0x7C, 0x54, 0x55, 0x45, 0x00, 
    0x20, 0x54, 0x54, 0x7C, 0x54, 
    0x7C, 0x0A, 0x09, 0x7F, 0x49, 
    0x32, 0x49, 0x49, 0x49, 0x32, 
    0x32, 0x48, 0x48, 0x48, 0x32, 
    0x32, 0x4A, 0x48, 0x48, 0x30, 
    0x3A, 0x41, 0x41, 0x21, 0x7A, 
    0x3A, 0x42, 0x40, 0x20, 0x78, 
    0x00, 0x9D, 0xA0, 0xA0, 0x7D, 
    0x39, 0x44, 0x44, 0x44, 0x39, 
    0x3D, 0x40, 0x40, 0x40, 0x3D, 
    0x3C, 0x24, 0xFF, 0x24, 0x24, 
    0x48, 0x7E, 0x49, 0x43, 0x66, 
    0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 
    0xFF, 0x09, 0x29, 0xF6, 0x20, 
    0xC0, 0x88, 0x7E, 0x09, 0x03, 
    0x20, 0x54, 0x54, 0x79, 0x41, 
    0x00, 0x00, 0x44, 0x7D, 0x41, 
    0x30, 0x48, 0x48, 0x4A, 0x32, 
    0x38, 0x40, 0x40, 0x22, 0x7A, 
    0x00, 0x7A, 0x0A, 0x0A, 0x72, 
    0x7D, 0x0D, 0x19, 0x31, 0x7D, 
    0x26, 0x29, 0x29, 0x2F, 0x28, 
    0x26, 0x29, 0x29, 0x29, 0x26, 
    0x30, 0x48, 0x4D, 0x40, 0x20, 
    0x38, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x38, 
    0x2F, 0x10, 0xC8, 0xAC, 0xBA, 
    0x2F, 0x10, 0x28, 0x34, 0xFA, 
    0x00, 0x00, 0x7B, 0x00, 0x00, 
    0x08, 0x14, 0x2A, 0x14, 0x22, 
    0x22, 0x14, 0x2A, 0x14, 0x08, 
    0xAA, 0x00, 0x55, 0x00, 0xAA, 
    0xAA, 0x55, 0xAA, 0x55, 0xAA, 
    0x00, 0x00, 0x00, 0xFF, 0x00, 
    0x10, 0x10, 0x10, 0xFF, 0x00, 
    0x14, 0x14, 0x14, 0xFF, 0x00, 
    0x10, 0x10, 0xFF, 0x00, 0xFF, 
    0x10, 0x10, 0xF0, 0x10, 0xF0, 
    0x14, 0x14, 0x14, 0xFC, 0x00, 
    0x14, 0x14, 0xF7, 0x00, 0xFF, 
    0x00, 0x00, 0xFF, 0x00, 0xFF, 
    0x14, 0x14, 0xF4, 0x04, 0xFC, 
    0x14, 0x14, 0x17, 0x10, 0x1F, 
    0x10, 0x10, 0x1F, 0x10, 0x1F, 
    0x14, 0x14, 0x14, 0x1F, 0x00, 
    0x10, 0x10, 0x10, 0xF0, 0x00, 
    0x00, 0x00, 0x00, 0x1F, 0x10, 
    0x10, 0x10, 0x10, 0x1F, 0x10, 
    0x10, 0x10, 0x10, 0xF0, 0x10, 
    0x00, 0x00, 0x00, 0xFF, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0xFF, 0x10, 
    0x00, 0x00, 0x00, 0xFF, 0x14, 
    0x00, 0x00, 0xFF, 0x00, 0xFF, 
    0x00, 0x00, 0x1F, 0x10, 0x17, 
    0x00, 0x00, 0xFC, 0x04, 0xF4, 
    0x14, 0x14, 0x17, 0x10, 0x17, 
    0x14, 0x14, 0xF4, 0x04, 0xF4, 
    0x00, 0x00, 0xFF, 0x00, 0xF7, 
    0x14, 0x14, 0x14, 0x14, 0x14, 
    0x14, 0x14, 0xF7, 0x00, 0xF7, 
    0x14, 0x14, 0x14, 0x17, 0x14, 
    0x10, 0x10, 0x1F, 0x10, 0x1F, 
    0x14, 0x14, 0x14, 0xF4, 0x14, 
    0x10, 0x10, 0xF0, 0x10, 0xF0, 
    0x00, 0x00, 0x1F, 0x10, 0x1F, 
    0x00, 0x00, 0x00, 0x1F, 0x14, 
    0x00, 0x00, 0x00, 0xFC, 0x14, 
    0x00, 0x00, 0xF0, 0x10, 0xF0, 
    0x10, 0x10, 0xFF, 0x10, 0xFF, 
    0x14, 0x14, 0x14, 0xFF, 0x14, 
    0x10, 0x10, 0x10, 0x1F, 0x00, 
    0x00, 0x00, 0x00, 0xF0, 0x10, 
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
    0xFF, 0xFF, 0xFF, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0xFF, 0xFF, 
    0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
    0x38, 0x44, 0x44, 0x38, 0x44, 
    0x7C, 0x2A, 0x2A, 0x3E, 0x14, 
    0x7E, 0x02, 0x02, 0x06, 0x06, 
    0x02, 0x7E, 0x02, 0x7E, 0x02, 
    0x63, 0x55, 0x49, 0x41, 0x63, 
    0x38, 0x44, 0x44, 0x3C, 0x04, 
    0x40, 0x7E, 0x20, 0x1E, 0x20, 
    0x06, 0x02, 0x7E, 0x02, 0x02, 
    0x99, 0xA5, 0xE7, 0xA5, 0x99, 
    0x1C, 0x2A, 0x49, 0x2A, 0x1C, 
    0x4C, 0x72, 0x01, 0x72, 0x4C, 
    0x30, 0x4A, 0x4D, 0x4D, 0x30, 
    0x30, 0x48, 0x78, 0x48, 0x30, 
    0xBC, 0x62, 0x5A, 0x46, 0x3D, 
    0x3E, 0x49, 0x49, 0x49, 0x00, 
    0x7E, 0x01, 0x01, 0x01, 0x7E, 
    0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 
    0x44, 0x44, 0x5F, 0x44, 0x44, 
    0x40, 0x51, 0x4A, 0x44, 0x40, 
    0x40, 0x44, 0x4A, 0x51, 0x40, 
    0x00, 0x00, 0xFF, 0x01, 0x03, 
    0xE0, 0x80, 0xFF, 0x00, 0x00, 
    0x08, 0x08, 0x6B, 0x6B, 0x08,
    0x36, 0x12, 0x36, 0x24, 0x36, 
    0x06, 0x0F, 0x09, 0x0F, 0x06, 
    0x00, 0x00, 0x18, 0x18, 0x00, 
    0x00, 0x00, 0x10, 0x10, 0x00, 
    0x30, 0x40, 0xFF, 0x01, 0x01, 
    0x00, 0x1F, 0x01, 0x01, 0x1E, 
    0x00, 0x19, 0x1D, 0x17, 0x12, 
    0x00, 0x3C, 0x3C, 0x3C, 0x3C, 
    0x00, 0x00, 0x00, 0x00, 0x00, 
};
#define _swap_int16_t(a, b) { int16_t t = a; a = b; b = t; }

class LEDPanel
{
public:
    
    int width;
    int height;
    int8_t data;
    int8_t cs;
    int8_t wr;
    int8_t rd;
    vector<uint8_t>leds;
    int matrixSize;
    LEDPanel() 
    {
        width = 24;
        height = 16;
        
        matrixSize = width*height/8;
        for (int i=0; i<matrixSize; i++) 
        {
            leds.push_back(0);
        }
    }
    void setup(int8_t data_, int8_t wr_, int8_t cs_, int8_t rd_=-1) 
    {
        data = data_;
        wr = wr_;
        cs = cs_;
        rd = rd_;
        
    }
    
    void begin(uint8_t type) 
    {
        pinMode(cs, OUTPUT);
        digitalWrite(cs, HIGH);
        pinMode(wr, OUTPUT);
        digitalWrite(wr, HIGH);
        pinMode(data, OUTPUT);
        
        if (rd >= 0) {
            pinMode(rd, OUTPUT);
            digitalWrite(rd, HIGH);
        }
        
        
        sendcommand(HT1632_SYS_EN);
        sendcommand(HT1632_LED_ON);
        sendcommand(HT1632_BLINK_OFF);
        sendcommand(HT1632_MASTER_MODE);
        sendcommand(HT1632_INT_RC);
        sendcommand(type);
        sendcommand(HT1632_PWM_CONTROL | 0xF);
        
    
    }
    
    void setBrightness(uint8_t pwm) 
    {
        if (pwm > 15) 
        {
            pwm = 15;
        }
        sendcommand(HT1632_PWM_CONTROL | pwm);
    }
    
    void blink(bool doBlink) 
    {
        if (doBlink) 
        {
            sendcommand(HT1632_BLINK_ON);
        }
        else
        {
            sendcommand(HT1632_BLINK_OFF);
        }
    }
    
    void setPixel(uint16_t i) 
    {
        leds[i/8] |= (1 << (i & 7)); 
    }
    
    void clrPixel(uint16_t i) 
    {
        leds[i/8] &= ~(1 << (i & 7));
    }
    
    void dumpScreen() 
    {
        printf("---------------------------------------\n");
        
        for (int i=0; i<matrixSize; i++) 
        {
            printf("0x");
            printf("0x%08x", leds[i]);
            printf(" ");
            if (i % 3 == 2) printf("\n");
        }
        
        printf("\n---------------------------------------\n");
    }
    
    // Will need to be changed
    void writeScreen()
    {
        
        digitalWrite(cs, LOW);
        
        writedata(HT1632_WRITE, 3);
        // send with address 0
        writedata(0, 7);
        
        for (int i=0; i<matrixSize; i+=2) 
        {
           writedata(((uint16_t)leds[i] << 8) | leds[i+1], 16);
        }
        digitalWrite(cs, HIGH);
    }
    
    
    void clearScreen()
    {
        for (size_t i=0; i<leds.size(); i++)
        {
            leds[i] = 0;
        }
        writeScreen();
    }
    
    
    void writedata(uint16_t d, uint8_t bits) 
    {
        pinMode(data, OUTPUT);
        for (uint16_t bit = 1<<(bits-1); bit; bit >>= 1) 
        {
            digitalWrite(wr, LOW);
            digitalWrite(data, (d & bit) ? HIGH : LOW);
            digitalWrite(wr, HIGH);
        }
        pinMode(data, INPUT);
    }
    
    
    void writeRAM(uint8_t addr, uint8_t data)
    {

        uint16_t d = HT1632_WRITE;
        d <<= 7;
        d |= addr & 0x7F;
        d <<= 4;
        d |= data & 0xF;
        
        digitalWrite(cs, LOW);
        writedata(d, 14);
        digitalWrite(cs, HIGH);
        
     }
    
    
    void sendcommand(uint8_t cmd) 
    {
        
        digitalWrite(cs, LOW);
        writedata((((uint16_t)HT1632_COMMAND << 8) | cmd) << 1, 12);
        digitalWrite(cs, HIGH);
        
    }
    
    
    void fillScreen() 
    {
        for (size_t i=0; i<leds.size(); i++) 
        {
            leds[i] = 0xFF;
        }
        writeScreen();
    }
    
    

    
};

class LEDMatrix
{
public:
    
    vector<LEDPanel*> panels;
    int width;
    int height;
    uint8_t cursor_x, cursor_y, textsize, textcolor;
    int rotation = 0;
    
    LEDMatrix()
    {
        width = 0;
        height = 16;
        wiringPiSetupGpio();

    }
    
    void addPanel(uint8_t& data, uint8_t& wr, uint8_t& cs)
    {
        LEDPanel* ledPanel = new LEDPanel();
        ledPanel->setup(data, wr, cs);
        panels.push_back(ledPanel);
        
        width = 24 * panels.size();
        
    }
    void setup(uint8_t data, uint8_t wr, vector<uint8_t>csPins) 
    {
        for(size_t i=0; i<csPins.size(); i++)
        {
            addPanel(data, wr, csPins[i]);
        }
    }
   
    
    
    void setPixel(uint8_t x, uint8_t y)
    {
        drawPixel(x, y, 1);
    }
    void clrPixel(uint8_t x, uint8_t y) 
    {
        drawPixel(x, y, 0);
    }
    
    void drawPixel(uint8_t x, uint8_t y, uint8_t color) {

        if((x < 0) || (x >= width) || (y < 0) || (y >= height)) return;
        
        
        switch(rotation) 
        { // Rotate pixel into device-specific coordinates
        case 1:
            _swap_int16_t(x, y);
            x = width  - 1 - x;
            break;
        case 2:
            x = width  - 1 - x;
            y = height - 1 - y;
            break;
        case 3:
            _swap_int16_t(x, y);
            y = height - 1 - y;
            break;
        }

        
        
        uint8_t m;
        // figure out which matrix controller it is
        m = x / 24;
        x %= 24;
        
        uint16_t i;
        
        if (x < 8) 
        {
            i = 7;
        }
        else 
        {
            if (x < 16)
            {
                i = 128 + 7;
            }else 
            {
                i = 256 + 7;
            }
        } 
        
        i -= (x % 8);
        
        if (y < 8) 
        {
            y *= 2;
        } else 
        {
            y = (y-8) * 2 + 1;
        } 
        
        i += y * 8;
        
        if (color) 
        {
            panels[m]->setPixel(i);
        }
        else
        {
            panels[m]->clrPixel(i);
        }
    }
    
    

    
    void begin(uint8_t type) 
    {
        for (size_t i=0; i<panels.size(); i++) 
        {
            panels[i]->begin(type);
        }
    }
    
    void clearScreen() 
    {
        for (size_t i=0; i<panels.size(); i++) 
        {
            panels[i]->clearScreen();
        }
    }
    
    void fillScreen() 
    {
        for (size_t i=0; i<panels.size(); i++) 
        {
            panels[i]->fillScreen();
        }
    }
    
    void setBrightness(uint8_t b) 
    {
        for (size_t i=0; i<panels.size(); i++)
        {
            panels[i]->setBrightness(b);
        }
    }
    
    void blink(bool b) 
    {
        for (size_t i=0; i<panels.size(); i++) 
        {
            panels[i]->blink(b);
        }
    }
    
    void writeScreen() 
    {
        for (size_t i=0; i<panels.size(); i++) 
        {
            panels[i]->writeScreen();
        }
    }
    
    // bresenham's algorithm - thx wikpedia
    void drawLine(int8_t x0, int8_t y0, int8_t x1, int8_t y1, uint8_t color) 
    {
        uint16_t steep = abs(y1 - y0) > abs(x1 - x0);
        if (steep) 
        {
            swap(x0, y0);
            swap(x1, y1);
        }
        
        if (x0 > x1) 
        {
            swap(x0, x1);
            swap(y0, y1);
        }
        
        uint16_t dx, dy;
        dx = x1 - x0;
        dy = abs(y1 - y0);
        
        int16_t err = dx / 2;
        int16_t ystep;
        
        if (y0 < y1) 
        {
            ystep = 1;
        } else
        {
            ystep = -1;
            
        }
        
        for (; x0<=x1; x0++) 
        {
            if (steep) 
            {
                drawPixel(y0, x0, color);
            } else
            {
                drawPixel(x0, y0, color);
            }
            err -= dy;
            if (err < 0) 
            {
                y0 += ystep;
                err += dx;
            }
        }
    }
    
    // draw a rectangle
    void drawRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, uint8_t color) 
    {
        drawLine(x, y, x+w-1, y, color);
        drawLine(x, y+h-1, x+w-1, y+h-1, color);
        
        drawLine(x, y, x, y+h-1, color);
        drawLine(x+w-1, y, x+w-1, y+h-1, color);
    }
    
    // fill a rectangle
    void fillRect(uint8_t x, uint8_t y, uint8_t w, uint8_t h, int8_t color) 
    {
        for (uint8_t i=x; i<x+w; i++) 
        {
            for (uint8_t j=y; j<y+h; j++) 
            {
                drawPixel(i, j, color);
            }
        }
    }
    
    
    
    // draw a circle outline
    void drawCircle(uint8_t x0, uint8_t y0, uint8_t r,  uint8_t color) 
    {
        int16_t f = 1 - r;
        int16_t ddF_x = 1;
        int16_t ddF_y = -2 * r;
        int16_t x = 0;
        int16_t y = r;
        
        drawPixel(x0, y0+r, color);
        drawPixel(x0, y0-r, color);
        drawPixel(x0+r, y0, color);
        drawPixel(x0-r, y0, color);
        
        while (x<y) {
            if (f >= 0) {
                y--;
                ddF_y += 2;
                f += ddF_y;
            }
            x++;
            ddF_x += 2;
            f += ddF_x;
            
            drawPixel(x0 + x, y0 + y, color);
            drawPixel(x0 - x, y0 + y, color);
            drawPixel(x0 + x, y0 - y, color);
            drawPixel(x0 - x, y0 - y, color);
            
            drawPixel(x0 + y, y0 + x, color);
            drawPixel(x0 - y, y0 + x, color);
            drawPixel(x0 + y, y0 - x, color);
            drawPixel(x0 - y, y0 - x, color);
            
        }
    }
    
    
    // fill a circle
    void fillCircle(uint8_t x0, uint8_t y0, uint8_t r, uint8_t color) {
        int16_t f = 1 - r;
        int16_t ddF_x = 1;
        int16_t ddF_y = -2 * r;
        int16_t x = 0;
        int16_t y = r;
        
        drawLine(x0, y0-r, x0, y0+r+1, color);
        
        while (x<y)
        {
            if (f >= 0) {
                y--;
                ddF_y += 2;
                f += ddF_y;
            }
            x++;
            ddF_x += 2;
            f += ddF_x;
            
            drawLine(x0+x, y0-y, x0+x, y0+y+1, color);
            drawLine(x0-x, y0-y, x0-x, y0+y+1, color);
            drawLine(x0+y, y0-x, x0+y, y0+x+1, color);
            drawLine(x0-y, y0-x, x0-y, y0+x+1, color);
        }
    }
    
    void setCursor(uint8_t x, uint8_t y) {
        cursor_x = x; 
        cursor_y = y;
    }
    
    void setTextSize(uint8_t s) {
        textsize = s;
    }
    
    void setTextColor(uint8_t c) {
        textcolor = c;
    }
    
    void write(uint8_t c) {
        if (c == '\n') {
            cursor_y += textsize*8;
            cursor_x = 0;
        } else if (c == '\r') {
            // skip em
        } else {
            drawChar(cursor_x, cursor_y, c, textcolor, textsize);
            cursor_x += textsize*6;
        }
    }
    
    // my print implementation
    void print(const char str[]) 
    {
        int size = sizeof(str) / sizeof(str[0]);
        for (int i = 0; i < size; ++i) 
        {
            write(str[i]);
        }
    }
    
    // draw a character
    void drawChar(uint8_t x, uint8_t y, char c, uint16_t color, uint8_t size) 
    {
        for (uint8_t i =0; i<5; i++ ) 
        {
            uint8_t line = font[(c*5)+i];
            for (uint8_t j = 0; j<8; j++) 
            {
                if (line & 0x1) 
                {
                    if (size == 1) // default size
                        drawPixel(x+i, y+j, color);
                    else 
                    {  // big size
                        fillRect(x+i*size, y+j*size, size, size, color);
                    } 
                }
                line >>= 1;
            }
        }
    }
    
    
    void drawBitmap(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t w, uint8_t h, uint8_t color) 
    {
        for (uint8_t j=0; j<h; j++) 
        {
            for (uint8_t i=0; i<w; i++ ) 
            {
                if (bitmap[i + (j/8)*w] & _BV(j%8)) 
                {
                    drawPixel(x+i, y+j, color);
                }
            }
        }
    }
    
};
